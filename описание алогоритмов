Все функции получают буквенное значение переменной word, далее:Atbash
Служит для шифрования и дешифрования методом Атбаш.
Запускается цикл, в котором каждой букве присваивается новое значение из таблицы ASCII. Функция ord возвращает символу под номером i его номер из таблица ASHII, далее этот номер вычитается из 219, если символ принадлежит определённому промежутку (219=97+122, т.е. равен сумме номеров символа a и z; 155=65+90, сумма номеров символов Z и a). В следующем действии функция chr возвращает символьный эквивалент получившемуся числу.
Функция выглядит следующим образом:Atbash(toCode: string): string;i: integer;i := 1 to length(toCode) do((toCode[i]>='a') and (toCode[i]<='z'))toCode[i]:=Chr(219-Ord(toCode[i]));((toCode[i]>='A') and (toCode[i]<='Z'))toCode[i]:=Chr(155-Ord(toCode[i]));:= toCode;;CaesarEncipher (…)
Служит для шифрования методом Цезаря.
Запускается цикл, в котором каждой букве присваивается новое значение из таблицы ASCII. Функция ord возвращает символу под номером i его номер из таблица ASHII, далее к этому номеру прибавляется число 3, тем самым осуществляется «сдвиг» порядкового номера на 3 позиции вправо.
Функция выглядит следующим образом:CaesarEncipher(toCode: string): string;i, T: integer;i := 1 to length(toCode) do begin[ i ] := Chr((Ord(toCode[ i ]) + 3));;:= toCode;;CaesarDecipher (…)
Служит для дешифрования методом Цезаря.
Процесс аналогичен шифрованию, но «сдвиг» элемента осуществляется на 3 позиции влево.
Функция выглядит следующим образом:CaesarDecipher(toDecode: string): string;i, T: integer;i := 1 to length(toDecode) do begin[ i ] := Chr((Ord(toDecode[ i ]) - 3));;:= toDecode;;PolibiusEncipher (…)
Служит для шифрования методом Полибия.
Запускается цикл, в котором каждой букве присваивается новое значение, состоящее из двух символов ix и jx, где оба символа берутся из первой строки: ix соответствует номеру строки элемента, jx номеру столбца.
Функция выглядит следующим образом:PolibiusEncipher(toCode: string): string;: integer;, jx: char;: string;:= '';i := 1 to length(toCode) do beginix := 'A' to 'H' dojx := 'A' to 'H' doTPolibius[ix, jx] = toCode[ i ] then begin:= s + ix + jx;;;;:= s; PolibiusDecipher (…)
Служит для дешифрования методом Полибия.
Запускается цикл while, в котором берётся первый символ, выражения требующего дешифровки (он представляет строку исходного символа), затем второй символ (он представляет столбец исходного символа). После этого в массиве TViginer на пересечении строки и столбца берётся нужный элемент. (Функция succ возвращает следующее буквенное значение, т.к. при шифровании элемент заменяется двумя символами, идущими подряд. Функция inc увеличивает величину на 2 ).: string =
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmopqrstuvwxyz';: array['A' .. 'H','A' .. 'H'] of char = (
('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'),
('I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'),
('Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X'),
('Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f'),
('g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'),
('o', 'p', 'q', 'r', 's', 't', 'u', 'v'),
('w', 'x', 'y', 'z', '1', '2', '3', '4'),
('5', '6', '7', '8', '9', '_', '+', '-') );
Функция выглядит следующим образом:PolibiusDecipher(toDecode: string): string;: integer;: string;:= '';:= 1;i <= length(toDecode) do begin:= s + TPolibius[toDecode[ i ], toDecode[succ(i)]];(i, 2);;:= s;GronsfeldEncipher (…)
Служит для шифрования методом Гронсфельда.
Запускается цикл for, в котором зашифрованный элемент образуется засчёт присвоения первоначальному элементу номера, равного сумме номера этого элемента, номера символа ключа и разности номера элемента «0», т.к. он идёт перед порядковым номером символа ключа (из таблицы ASCHII).
Функция выглядит следующим образом:GronsfeldEncipher(toCode, K: string): string;i, T: integer;i := 1 to length(toCode) do begin[ i ] := Chr(Ord(toCode[ i ])+(Ord(K[(pred(i) mod length(K)) + 1]) - Ord('0')));;:= toCode;;GronsfeldDecipher (…)
Служит для дешифрования методом Гронсфельда.
Принцип аналогичен шифрованию, с разницей в том, что сдвиг, образованный ключом в данном случае снимается.
Функция выглядит следующим образом:GronsfeldDecipher(toDecode, K: string): string;i, T: integer;i := 1 to length(toDecode) do begin[ i ] := Chr(Ord(toDecode[i])-(Ord(K[(pred(i) mod length(K)) + 1]) - Ord('0')));;:= toDecode;;ViginerEncipher (…)
Служит для шифрования методом Виженера.
Запускается цикл, в котором новое значение символа получается благодаря:
в начале использованию переменной, которой присваивается значение, равное номеру элемента, вычисленного функцией pos (функция pos ищет первое пересечение буквы кодового слова и массива TViginer, затем выдаёт номер данного элемента в массиве), минус 1
конечный элемент берётся из массива TViginer. Его номер равен номеру элемента пересечения символа вводимого текста минус 1, прибавить подсчитанную выше переменную, взять целую часть от деления всего этого на длину массива (52 символа) и прибавить 1.
Функция выглядит следующим образом:: string =
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmopqrstuvwxyz';ViginerEncipher(toCode, K: string): string;: integer;: byte;: string;:= '';i := 1 to length(toCode) do begin:= pred(pos(K[ (pred(i) mod length(K)) + 1 ], TViginer));:= s + TViginer[ ((pred(pos(toCode[ i ], TViginer)) + currK) mod length(TViginer))+1];;:= s;;ViginerDecipher (…)
Служит для дешифрования методом Виженера.
Отличается от предыдущего шифрования номером символа, берущегося из массива. Он равен номеру пересечения элемента, уменьшенному на значение подсчитанной ранее переменной.
Функция выглядит следующим образом:ViginerDecipher(toDecode, K: string): string;, T: integer;: byte;: string;:= '';i := 1 to length(toDecode) do begin:= pred(pos(K[ (pred(i) mod length(K)) + 1 ], TViginer));:= pred(pos(toDecode[ i ], TViginer)) - currK;	f T < 0 then inc(T, length(TViginer));:= s + TViginer[T + 1];;:= s;
end;
.	Все функции возвращают переменную toCode или toDecode в значении s.
